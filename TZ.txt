Тестовое Задание


Необходимо реализовать backend-приложение – собственную систе-му аутентификации и авторизации. Приложение не должно быть полностью основано на соответствующих возможностях фреймвор-ков, идущих «из коробки».
Основной задачей разработки является продумывание и предложение собственной системы доступа к ресурсам (Вы должны продумать схему БД, описать ее составляющие , которые будут отражать правила, к ка-ким ресурсам и какие действия может совершать определенный пользо-ватель).
Приложение должно реализовывать следующий функционал:
Основные модули системы
1. Взаимодействие с пользователем
Позволяет пользователям регистрироваться, входить в систему, выходить из учетной записи, обновлять свои данные и удалять аккаунт.
	Регистрация: Ввод имени (фамилии, отчества), email, пароля, повтор пароля.
	Обновление информации: Пользователь может редактировать свой профиль.
	Удаление пользователя: Удаление аккаунта (мягкое) — пользователь инициирует удаление, происходит logout, пользователь больше не мо-жет залогиниться, но при этом в базе учетная запись остается со стату-сом is_active=False.
	Login: пользователь входить в систему по email и паролю.
	Logout: пользователь выходит из системы.
* После login система при последующих обращениях должна идентифициро-вать пользователя.
2. Система разграничения прав доступа. 
	Вы должны продумать и в текстовом файле или в REAME.md описать схему вашей структуры управления ограничениями доступа.
	Реализованы соответствующие таблицы в БД.
	Таблицы заполнены тестовыми данными для минимальной отработки приложения для демонстрации работающей системы.
	Если пользователь имеет доступ к ресурсу по вышеописанным прави-лам, ему выдается запрашиваемый ресурс. Если по входящему запросу не удается определить залогиненного пользователя, выдается ошибка 401. Если пользователь определен, но запрашиваемый ресурс ему не доступен 403 ошибка — Forbidden. 
	Реализовать API с возможностью получения и изменения этих правил пользователю, имеющему роль администратора.

3. Минимальные вымышленные объекты бизнес-приложения, к которым могла бы применяться созданная система.
Таблицы в БД создавать не требуется. Можно просто написать Mock-View, ко-торые по обращениям будут выдавать список потенциальных объектов или описанные выше ошибки.

Выбор технологий на Ваше усмотрение. Наш совет — DRF + Postgres.

P.S. Даже если не удастся полностью выполнить задание, у обучающего-ся появится понимание различий между аутентификацией и авторизаци-ей, знания о формировании jwt-токенов, что такое сессии, как они связа-ны с вопросами и ответами клиента и сервера, как работает login и logout в системах, как можно управлять безопасностью любого приложения.



Если вы долистали до этого места и вам кажется, что задание очень сложное и вам пока недостаточно знаний, чтобы придумать такую реали-зацию, поменяйте цвет текста в строках ниже.

Про аутентификацию:
Перевести пользовательский пароль для хранения в БД поможет библиотека bcrypt.
Для создания токена из id пользователя поможет библиотека jwt.
Можно определять пользователя из header Authorization : Bearer {user_token}, либо после логина создавать сессию (доп таблица sessions, и в response устанавливать пользователю Cookie с sessionid, expire_at …
В request сразу присваивать request.user перед обработкой запроса в кастомном Middleware в Django.

Про авторизацию:
Можно создать таблицы:
roles для описания пользовательских ролей в проекте (админ, менеджер, пользова-тель, гость);
business_elements для описания объектов приложения к которым будет осуществлять-ся доступ (пользователи, товары, магазины, заказы, сами правила доступа);
access_roles_rules для хранения правил доступа определенной роли к определенному блоку приложения (столбцы role_id, element_id, read_permission, read_all_permission, create_permission,update_permission, update_all_permission, delete_permission, de-lete_all_permission).
Все столбцы, оканчивающиеся на _permission, имеют тип bool и отражают, что поль-зователь может делать с объектами — со всеми объктами, или может что-то делать с объектами, которые создавал сам (предполагается в табличках были бы поля owner (ссылка на user.id)
